The executor from `futures` we used in the previous section is intentionally
quite limited. It works quite well, but if you are going to build a real-world
application, you will likely want to use the executor from one of the *other*
runtimes in the Rust ecosystem.

> ### The `futures` and `tokio` Crates
>
> Whenever you see code from the `trpl` crate throughout the rest of the
> chapter, it will be re-exporting code from the `futures` and [`tokio`][tokio]
> crates.
>
> - The `futures` crate is an official home for Rust experimentation for async
>   code, and is actually where the `Future` type was originally designed.
>
> - Tokio is the most widely used async runtime in Rust today, especially (but
>   not only!) for web applications. There are other great options out there,
>   too, and they may be more suitable for your purposes. We are using Tokio
>   because it is the most widely-used runtime—not as a judgment call on whether
>   it is the *best* runtime!

Okay, now let’s start exploring. Going forward, we will use a new `async_main`
macro so that we can use `async fn` with a `main` function. Under the hood, this
little utility macro from Tokio sets up the Tokio runtime and wires up a call
kind of like we saw with `futures::executor::block_on` in the previous section.
Now we can use `async` blocks directly in `main` and not worry about wiring up
the runtime ourselves:

```rust
use trpl::async_main;

#[async_main]
async fn main() {
    async {
        println!("Hello, world!");
    }.await;
}
```



[tokio]: https://tokio.rs

